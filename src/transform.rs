use openapi::{Spec, Info, Contact, License, Operation, Operations, Schema, Response};
use acquisition::EndpointDetails;

use std::collections::BTreeMap;
use std::convert::TryInto;
use std::iter::FromIterator;
use errors::*;
use reqwest::Method;

fn build_paths<'a, T: Iterator<Item=&'a EndpointDetails>>(endpoints: T) -> Result<BTreeMap<String, Operations>> {
    Ok(BTreeMap::from_iter(endpoints.map(|e| {
        // Pass error onwards instead
        (e.uri.clone(), e.try_into().expect("Failed to generate path"))
    })))
}

fn build_operation<'a>(method: Method, details: &'a EndpointDetails) -> Option<Operation> {
    if details.methods.contains(&method) {
        Some(Operation {
            summary: None,
            description: None,
            consumes: None,
            produces: None,
            schemes: None,
            tags: None,
            operation_id: None,
            // TODO: Implement
            responses: BTreeMap::default(),
            // TODO: Implement this too
            parameters: None,
        })
    } else {
        // This operation is not implemented for the given endpoint
        None
    }
}

impl<'a> TryInto<Operations> for &'a EndpointDetails {
    type Error = Error;

    fn try_into(self) -> Result<Operations> {
        Ok(Operations {
            get: build_operation(Method::Get, &self),
            post: build_operation(Method::Post, &self),
            put: build_operation(Method::Put, &self),
            patch: None,
            delete: build_operation(Method::Delete, &self),
            options: None,
            head: None,
            parameters: None
        })
    }
}

fn build_definitions<'a, T: Iterator<Item=&'a EndpointDetails>>(endpoints: T) -> Result<BTreeMap<String, Schema>> {
    Ok(BTreeMap::default())
}

fn build_responses<'a, T: Iterator<Item=&'a EndpointDetails>>(endpoints: T) -> Result<BTreeMap<String, Response>> {
    Ok(BTreeMap::default())
}

pub fn build_spec(endpoints: Vec<EndpointDetails>) -> Result<Spec> {
    Ok(Spec {
        swagger: "2.0".to_owned(),
        info: Info {
            title: Some("Exact Online REST API".to_owned()),
            description: Some("Autogenerated using exact-openapi-gen".to_owned()),
            terms_of_service: None,
            contact: Some(Contact {
                name: Some("Daan de Graaf".to_owned()),
                url: Some("https://github.com/wildarch".to_owned()),
                email: Some("daandegraaf9@gmail.com".to_owned()),
            }),
            license: Some(License {
                name: Some("MIT".to_owned()),
                url: None,
            }),
            version: Some(String::from(env!("CARGO_PKG_VERSION"))),
        },
        host: Some("start.exactonline.nl".to_owned()),
        base_path: Some("/".to_owned()),
        schemes: Some(["https".to_owned()].to_vec()),
        consumes: Some(["application/json".to_owned()].to_vec()),
        produces: Some(["application/json".to_owned()].to_vec()),
        tags: None,
        paths: build_paths(endpoints.iter())?,
        definitions: Some(build_definitions(endpoints.iter())?),
        parameters: None,
        responses: Some(build_responses(endpoints.iter())?),
        // TODO: Set the correct security definitions
        security_definitions: None
    })
}